#!/usr/bin/perl
#v3.0

# subset_mers.pl kmers_fwd_rc 25
#  subset_mers.pl kmers_fwd_rc
# k is optional


# Organizes input file into multiple buckets based on initial k-mers
# 
# Alternative implementation:
#  - parse into dict that is formed from first $k chars of mer.
#  - Periodically dump dict to files (appending), zero, and repeat.
# Benefit of alternative implementation:
#  - Shorter?
#  - Simpler?
#  - Clearer objective?
#  - Functions on unsorted input.
#  - Maybe faster? (probably not?)
#  - Maybe less memory use? (probably not?)
#
# Another alternative: Put the meat of the while loop at the end instead into the middle of the loops below
#  - Simpler
#  - Shorter
#  - Lower memory usage
#  - (negative:) Still requires sorted input.
#
# Can we figure out an alternative that doesn't involve us building a half a bazillion files?

no warnings 'deprecated';

my $infile=$ARGV[0]; # probably kmers_fwd_rc
my $k=5;
my @bases = qw(A C G T); # shortcut to accommodate perl feature removal

if ($ARGV[1]) {
    $k=$ARGV[1];
}

if ($k > 5) {
    my $count=0;
    #foreach $w qw(A C G T) {
    foreach $w (@bases) {
	foreach $x (@bases) {
	    foreach $y (@bases) {
		foreach $m (@bases) {
		    foreach $n (@bases) {
			#foreach $t qw(A C G T) {
			#foreach $s qw(A C G T) {
			my $z=$w.$x.$y.$m.$n;
			$zarray[$count]=$z;
			$count++;
			#}
			#}
		    }
		}
	    }
	}
    }
} elsif ($k == 5) {
    my $count=0;
    foreach $w (@bases) {
	foreach $x (@bases) {
	    foreach $y (@bases) {
		foreach $m (@bases) {
		    #foreach $t qw(A C G T) {
		    #foreach $s qw(A C G T) {
		    my $z=$w.$x.$y.$m;
		    $zarray[$count]=$z;
		    $count++;
		    #}
		    #}
		}
	    }
	}
    }
} elsif ($k == 4) {
    my $count=0;
    foreach $w (@bases) {
	foreach $x (@bases) {
	    foreach $y (@bases) {
		my $z=$w.$x.$y;
		$zarray[$count]=$z;
		$count++;
	    }
	}
    }
} elsif ($k < 4) {
    my $count=0;
    foreach $w (@bases) {
	my $z=$w;
	$zarray[$count]=$z;
	$count++;
    }
}

# Above creates a dictionary from N (a sequential number) to:
#  - a corresponding 5-mer for k > 5.
#  - a corresponding k-1-mer for k = 4 or k = 5.
#  - a corresponding 1-mer (monomer) for k < 4.


# This main code appears to put each line into a file named <mer-prefix>.mers 
# where <mer-prefix> is based on k to be:
#  k>5: first 5 characters of line
#  k<4: first character of line
#  else: first k-1 characters of line
$count=0;
open IN,"$infile";
my $out=$zarray[$count].".mers";
open OUT,">$out";
while (my $line=<IN>){
    if ($line =~ /^$zarray[$count]/) {
	print OUT "$line";
    } else {
	close OUT;
	until ($line =~ /^$zarray[$count]/) {
	    $count++;
	    # The next 3 lines only create empty .mers files; are they necessary? FIXME TODO XXX - JN
	    $out=$zarray[$count].".mers";
	    open OUT,">$out";
	    close OUT;

	}

	$out=$zarray[$count].".mers";
	open OUT,">$out";
	print OUT "$line";
	
    }
}
close OUT;
